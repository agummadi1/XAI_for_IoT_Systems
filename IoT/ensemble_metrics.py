# -*- coding: utf-8 -*-
"""Ensemble.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oxYM7xkRcfdaSM-5rj16t58C1O08dDtX
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import BaggingClassifier, StackingClassifier, VotingClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# List of 9 CSV files
csv_files = [
    'device1_top_20_features.csv',
    'device2_top_20_features.csv',
    'device3_top_20_features.csv',
    'device4_top_20_features.csv',
    'device5_top_20_features.csv',
    'device6_top_20_features.csv',
    'device7_top_20_features.csv',
    'device8_top_20_features.csv',
    'device9_top_20_features.csv'
]

for i, csv_file in enumerate(csv_files):
    # Initialize an empty DataFrame to store performance metrics for each CSV file
    metrics_df = pd.DataFrame(columns=['Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score'])

    print(f"Processing file {i + 1} of 9: {csv_file}")

    # Load dataset from the current CSV file
    data = pd.read_csv(csv_file)

    # Separate features and labels
    X = data.drop(columns=['label'])
    y = data['label']

    # Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Bagging
    bagging_classifier = BaggingClassifier(base_estimator=DecisionTreeClassifier(), n_estimators=100, random_state=42)
    bagging_classifier.fit(X_train, y_train)
    bagging_pred = bagging_classifier.predict(X_test)

    # Stacking
    stacking_classifier = StackingClassifier(estimators=[('bagging', bagging_classifier)], final_estimator=LogisticRegression(), stack_method='predict_proba')
    stacking_classifier.fit(X_train, y_train)
    stacking_pred = stacking_classifier.predict(X_test)

    # Voting
    voting_classifier = VotingClassifier(estimators=[('bagging', bagging_classifier)], voting='hard')
    voting_classifier.fit(X_train, y_train)
    voting_pred = voting_classifier.predict(X_test)

    # Blending (Manual Implementation)
    base_learners = [bagging_classifier]
    blend_pred = np.zeros((len(X_test), len(np.unique(y))))  # Assuming you have multiple classes
    for base_learner in base_learners:
        base_learner.fit(X_train, y_train)
        blend_pred += base_learner.predict_proba(X_test)
    blend_pred = np.argmax(blend_pred, axis=1) + 1  # Convert to class labels

    # Calculate performance metrics for Bagging
    accuracy_bagging = accuracy_score(y_test, bagging_pred)
    precision_bagging = precision_score(y_test, bagging_pred, average='weighted')
    recall_bagging = recall_score(y_test, bagging_pred, average='weighted')
    f1_bagging = f1_score(y_test, bagging_pred, average='weighted')

    # Calculate performance metrics for Stacking
    accuracy_stacking = accuracy_score(y_test, stacking_pred)
    precision_stacking = precision_score(y_test, stacking_pred, average='weighted')
    recall_stacking = recall_score(y_test, stacking_pred, average='weighted')
    f1_stacking = f1_score(y_test, stacking_pred, average='weighted')

    # Calculate performance metrics for Voting
    accuracy_voting = accuracy_score(y_test, voting_pred)
    precision_voting = precision_score(y_test, voting_pred, average='weighted')
    recall_voting = recall_score(y_test, voting_pred, average='weighted')
    f1_voting = f1_score(y_test, voting_pred, average='weighted')

    # Calculate performance metrics for Blending
    accuracy_blending = accuracy_score(y_test, blend_pred)
    precision_blending = precision_score(y_test, blend_pred, average='weighted')
    recall_blending = recall_score(y_test, blend_pred, average='weighted')
    f1_blending = f1_score(y_test, blend_pred, average='weighted')

    # Append metrics to the DataFrame
    metrics_df = metrics_df.append({'Model': 'Bagging', 'Accuracy': accuracy_bagging, 'Precision': precision_bagging, 'Recall': recall_bagging, 'F1 Score': f1_bagging}, ignore_index=True)
    metrics_df = metrics_df.append({'Model': 'Stacking', 'Accuracy': accuracy_stacking, 'Precision': precision_stacking, 'Recall': recall_stacking, 'F1 Score': f1_stacking}, ignore_index=True)
    metrics_df = metrics_df.append({'Model': 'Voting', 'Accuracy': accuracy_voting, 'Precision': precision_voting, 'Recall': recall_voting, 'F1 Score': f1_voting}, ignore_index=True)
    metrics_df = metrics_df.append({'Model': 'Blending', 'Accuracy': accuracy_blending, 'Precision': precision_blending, 'Recall': recall_blending, 'F1 Score': f1_blending}, ignore_index=True)

    # Create a table image using matplotlib
    plt.figure(figsize=(10, 6))
    plt.axis('off')  # Turn off axis
    plt.table(cellText=metrics_df.values, colLabels=metrics_df.columns, cellLoc='center', loc='center', colColours=['#f2f2f2']*len(metrics_df.columns))
    plt.tight_layout()

    # Save the table as a JPG image
    plt.savefig(f'd{i + 1}_ensemble_metrics.jpg', format='jpg')

    # Display the table
    plt.show()